{"version":3,"file":"react-easy-crop.min.js","sources":["../../src/helpers.ts","../../src/Cropper.tsx"],"sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import * as React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'cover' | 'horizontal-cover' | 'vertical-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  roundCropAreaPixels?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  cropperProps: React.HTMLAttributes<HTMLDivElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean\n  onWheelRequest?: (e: WheelEvent) => boolean\n  setCropperRef?: (ref: React.RefObject<HTMLDivElement>) => void\n  setImageRef?: (ref: React.RefObject<HTMLImageElement>) => void\n  setVideoRef?: (ref: React.RefObject<HTMLVideoElement>) => void\n  setMediaSize?: (size: MediaSize) => void\n  setCropSize?: (size: Size) => void\n  nonce?: string\n  keyboardStep: number\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n  mediaObjectFit: String | undefined\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\nconst KEYBOARD_STEP = 1\n\ntype GestureEvent = UIEvent & {\n  rotation: number\n  scale: number\n  clientX: number\n  clientY: number\n}\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    cropperProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n    keyboardStep: KEYBOARD_STEP,\n  }\n\n  cropperRef: React.RefObject<HTMLDivElement> = React.createRef()\n  imageRef: React.RefObject<HTMLImageElement> = React.createRef()\n  videoRef: React.RefObject<HTMLVideoElement> = React.createRef()\n  containerPosition: Point = { x: 0, y: 0 }\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  gestureZoomStart = 0\n  gestureRotationStart = 0\n  isTouching = false\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n  currentDoc: Document | null = typeof document !== 'undefined' ? document : null\n  currentWindow: Window | null = typeof window !== 'undefined' ? window : null\n  resizeObserver: ResizeObserver | null = null\n  canonicalCroppedAreaPercentages: Area | null = null\n  cachedCroppedAreaPixels: Area | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n    mediaObjectFit: undefined,\n  }\n\n  componentDidMount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (this.containerRef) {\n      if (this.containerRef.ownerDocument) {\n        this.currentDoc = this.containerRef.ownerDocument\n      }\n      if (this.currentDoc.defaultView) {\n        this.currentWindow = this.currentDoc.defaultView\n      }\n\n      this.initResizeObserver()\n      // only add window resize listener if ResizeObserver is not supported. Otherwise, it would be redundant\n      if (typeof window.ResizeObserver === 'undefined') {\n        this.currentWindow.addEventListener('resize', this.computeSizes)\n      }\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.onGestureStart as EventListener)\n    }\n\n    this.currentDoc.addEventListener('scroll', this.onScroll)\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = this.currentDoc.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      if (this.props.nonce) {\n        this.styleRef.setAttribute('nonce', this.props.nonce)\n      }\n      this.styleRef.innerHTML = cssStyles\n      this.currentDoc.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef.current && this.imageRef.current.complete) {\n      this.onMediaLoad()\n    }\n\n    // set image and video refs in the parent if the callbacks exist\n    if (this.props.setImageRef) {\n      this.props.setImageRef(this.imageRef)\n    }\n\n    if (this.props.setVideoRef) {\n      this.props.setVideoRef(this.videoRef)\n    }\n\n    if (this.props.setCropperRef) {\n      this.props.setCropperRef(this.cropperRef)\n    }\n  }\n\n  componentWillUnmount() {\n    if (!this.currentDoc || !this.currentWindow) return\n    if (typeof window.ResizeObserver === 'undefined') {\n      this.currentWindow.removeEventListener('resize', this.computeSizes)\n    }\n    this.resizeObserver?.disconnect()\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.objectFit !== this.props.objectFit) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef.current?.load()\n    }\n\n    const objectFit = this.getObjectFit()\n    if (objectFit !== this.state.mediaObjectFit) {\n      this.setState({ mediaObjectFit: objectFit }, this.computeSizes)\n    }\n  }\n\n  initResizeObserver = () => {\n    if (typeof window.ResizeObserver === 'undefined' || !this.containerRef) {\n      return\n    }\n    let isFirstResize = true\n    this.resizeObserver = new window.ResizeObserver((entries) => {\n      if (isFirstResize) {\n        isFirstResize = false // observe() is called on mount, we don't want to trigger a recompute on mount\n        return\n      }\n      this.computeSizes()\n    })\n    this.resizeObserver.observe(this.containerRef)\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    if (!this.currentDoc) return\n    this.currentDoc.removeEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.removeEventListener('mouseup', this.onDragStopped)\n    this.currentDoc.removeEventListener('touchmove', this.onTouchMove)\n    this.currentDoc.removeEventListener('touchend', this.onDragStopped)\n    this.currentDoc.removeEventListener('gesturechange', this.onGestureChange as EventListener)\n    this.currentDoc.removeEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.currentDoc.removeEventListener('scroll', this.onScroll)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  getObjectFit() {\n    if (this.props.objectFit === 'cover') {\n      const mediaRef = this.imageRef.current || this.videoRef.current\n\n      if (mediaRef && this.containerRef) {\n        this.containerRect = this.containerRef.getBoundingClientRect()\n        const containerAspect = this.containerRect.width / this.containerRect.height\n        const naturalWidth =\n          this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n        const naturalHeight =\n          this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n        const mediaAspect = naturalWidth / naturalHeight\n\n        return mediaAspect < containerAspect ? 'horizontal-cover' : 'vertical-cover'\n      }\n      return 'horizontal-cover'\n    }\n\n    return this.props.objectFit\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef.current || this.videoRef.current\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      this.saveContainerPosition()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth =\n        this.imageRef.current?.naturalWidth || this.videoRef.current?.videoWidth || 0\n      const naturalHeight =\n        this.imageRef.current?.naturalHeight || this.videoRef.current?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.state.mediaObjectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      // set media size in the parent\n      if (this.props.setMediaSize) {\n        this.props.setMediaSize(this.mediaSize)\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n\n      this.setState({ cropSize }, () => {\n        if (!this.applyCanonical(cropSize)) {\n          this.recomputeCropPosition()\n        }\n      })\n\n      // pass crop size to parent\n      if (this.props.setCropSize) {\n        this.props.setCropSize(cropSize)\n      }\n\n      return cropSize\n    }\n  }\n\n  applyCanonical = (cropSize: Size): boolean => {\n    if (!this.canonicalCroppedAreaPercentages) return false\n    const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n      this.canonicalCroppedAreaPercentages,\n      this.mediaSize,\n      this.props.rotation,\n      cropSize,\n      this.props.minZoom,\n      this.props.maxZoom\n    )\n    if (this.props.onZoomChange && Math.abs(zoom - this.props.zoom) > 1e-6) {\n      this.props.onZoomChange(zoom)\n    }\n    const dx = Math.abs(crop.x - this.props.crop.x)\n    const dy = Math.abs(crop.y - this.props.crop.y)\n    if (dx > 1e-6 || dy > 1e-6) {\n      this.props.onCropChange(crop)\n    }\n    this.emitCropData()\n    return true\n  }\n\n  saveContainerPosition = () => {\n    if (this.containerRef) {\n      const bounds = this.containerRef.getBoundingClientRect()\n      this.containerPosition = { x: bounds.left, y: bounds.top }\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent | GestureEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('mousemove', this.onMouseMove)\n    this.currentDoc.addEventListener('mouseup', this.onDragStopped)\n    this.saveContainerPosition()\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onScroll = (e: Event) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.saveContainerPosition()\n  }\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    if (!this.currentDoc) return\n    this.isTouching = true\n    if (this.props.onTouchRequest && !this.props.onTouchRequest(e)) {\n      return\n    }\n\n    this.currentDoc.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    this.currentDoc.addEventListener('touchend', this.onDragStopped)\n\n    this.saveContainerPosition()\n\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onGestureStart = (e: GestureEvent) => {\n    if (!this.currentDoc) return\n    e.preventDefault()\n    this.currentDoc.addEventListener('gesturechange', this.onGestureChange as EventListener)\n    this.currentDoc.addEventListener('gestureend', this.onGestureEnd as EventListener)\n    this.gestureZoomStart = this.props.zoom\n    this.gestureRotationStart = this.props.rotation\n  }\n\n  onGestureChange = (e: GestureEvent) => {\n    e.preventDefault()\n    if (this.isTouching) {\n      // this is to avoid conflict between gesture and touch events\n      return\n    }\n\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.gestureZoomStart - 1 + e.scale\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n    if (this.props.onRotationChange) {\n      const newRotation = this.gestureRotationStart + e.rotation\n      this.props.onRotationChange(newRotation)\n    }\n  }\n\n  onGestureEnd = (e: GestureEvent) => {\n    this.cleanEvents()\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (!this.currentWindow) return\n    if (this.rafDragTimeout) this.currentWindow.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = this.currentWindow.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.isTouching = false\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    if (!this.currentDoc || !this.currentWindow) return\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) this.currentWindow.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = this.currentWindow.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center, { shouldUpdatePosition: false })\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    if (!this.currentWindow) return\n    if (this.props.onWheelRequest && !this.props.onWheelRequest(e)) {\n      return\n    }\n\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point, { shouldUpdatePosition: true })\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = this.currentWindow.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point, containerTopLeft: Point): Point => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - containerTopLeft.x),\n      y: this.containerRect.height / 2 - (y - containerTopLeft.y),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point, { shouldUpdatePosition = true } = {}) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n\n    if (shouldUpdatePosition) {\n      const zoomPoint = this.getPointOnContainer(point, this.containerPosition)\n      const zoomTarget = this.getPointOnMedia(zoomPoint)\n      const requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            newZoom,\n            this.props.rotation\n          )\n        : requestedPosition\n\n      this.props.onCropChange(newPosition)\n    }\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n\n    this.canonicalCroppedAreaPercentages = croppedAreaPercentages\n    this.cachedCroppedAreaPixels = croppedAreaPixels\n\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n\n    this.canonicalCroppedAreaPercentages = croppedAreaPercentages\n    this.cachedCroppedAreaPixels = croppedAreaPixels\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  onKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    const { crop, onCropChange, keyboardStep, zoom, rotation } = this.props\n    let step = keyboardStep\n\n    if (!this.state.cropSize) return\n\n    // if the shift key is pressed, reduce the step to allow finer control\n    if (event.shiftKey) {\n      step *= 0.2\n    }\n\n    let newCrop = { ...crop }\n\n    switch (event.key) {\n      case 'ArrowUp':\n        newCrop.y -= step\n        event.preventDefault()\n        break\n      case 'ArrowDown':\n        newCrop.y += step\n        event.preventDefault()\n        break\n      case 'ArrowLeft':\n        newCrop.x -= step\n        event.preventDefault()\n        break\n      case 'ArrowRight':\n        newCrop.x += step\n        event.preventDefault()\n        break\n      default:\n        return\n    }\n\n    if (this.props.restrictPosition) {\n      newCrop = restrictPosition(newCrop, this.mediaSize, this.state.cropSize, zoom, rotation)\n    }\n\n    if (!event.repeat) {\n      this.props.onInteractionStart?.()\n    }\n\n    onCropChange(newCrop)\n  }\n\n  onKeyUp = (event: React.KeyboardEvent<HTMLDivElement>) => {\n    switch (event.key) {\n      case 'ArrowUp':\n      case 'ArrowDown':\n      case 'ArrowLeft':\n      case 'ArrowRight':\n        event.preventDefault()\n        break\n      default:\n        return\n    }\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      cropperProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      roundCropAreaPixels,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n    } = this.props\n\n    const objectFit = this.state.mediaObjectFit ?? this.getObjectFit()\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={this.imageRef}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              playsInline\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={this.videoRef}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            ref={this.cropperRef}\n            style={{\n              ...cropAreaStyle,\n              width: roundCropAreaPixels\n                ? Math.round(this.state.cropSize.width)\n                : this.state.cropSize.width,\n              height: roundCropAreaPixels\n                ? Math.round(this.state.cropSize.height)\n                : this.state.cropSize.height,\n            }}\n            tabIndex={0}\n            onKeyDown={this.onKeyDown}\n            onKeyUp={this.onKeyUp}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n            {...cropperProps}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"],"names":["getCropSize","mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","rotation","_a","rotateSize","width","height","fittingWidth","Math","min","fittingHeight","restrictPosition","position","mediaSize","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","clamp","getDistanceBetweenPoints","pointA","pointB","sqrt","pow","getRotationBetweenPoints","atan2","PI","computeCroppedArea","crop","limitAreaFn","limitArea","noOp","mediaBBoxSize","mediaNaturalBBoxSize","naturalWidth","naturalHeight","croppedAreaPercentages","widthInPixels","round","heightInPixels","sizePixels","croppedAreaPixels","__assign","max","value","_max","getInitialCropFromCroppedAreaPercentages","minZoom","maxZoom","getInitialCropFromCroppedAreaPixels","mediaZoom","getMediaZoom","getZoomFromCroppedAreaPixels","cropZoom","getCenter","a","b","rotRad","abs","cos","sin","classNames","args","_i","arguments","length","filter","join","trim","Cropper","_super","_this","apply","this","cropperRef","React","createRef","imageRef","videoRef","containerPosition","containerRef","styleRef","containerRect","dragStartPosition","dragStartCrop","gestureZoomStart","gestureRotationStart","isTouching","lastPinchDistance","lastPinchRotation","rafDragTimeout","rafPinchTimeout","wheelTimer","currentDoc","document","currentWindow","window","resizeObserver","canonicalCroppedAreaPercentages","cachedCroppedAreaPixels","state","hasWheelJustStarted","mediaObjectFit","undefined","initResizeObserver","ResizeObserver","isFirstResize","entries","computeSizes","observe","preventZoomSafari","e","preventDefault","cleanEvents","removeEventListener","onMouseMove","onDragStopped","onTouchMove","onGestureChange","onGestureEnd","onScroll","clearScrollEvent","onWheel","clearTimeout","onMediaLoad","emitCropData","setInitialCrop","props","onMediaLoaded","initialCroppedAreaPercentages","onCropChange","onZoomChange","initialCroppedAreaPixels","_b","mediaRef","current","getBoundingClientRect","saveContainerPosition","containerAspect","videoWidth","_c","_d","videoHeight","mediaAspect","renderedMediaSize","offsetWidth","offsetHeight","setMediaSize","cropSize_1","_e","_f","onCropSizeChange","setState","applyCanonical","recomputeCropPosition","setCropSize","dx","dy","bounds","left","top","onMouseDown","addEventListener","onDragStart","getMousePoint","onDrag","onTouchStart","onTouchRequest","passive","touches","onPinchStart","getTouchPoint","onPinchMove","onGestureStart","point","newZoom","scale","setNewZoom","shouldUpdatePosition","onRotationChange","newRotation","onInteractionStart","cancelAnimationFrame","requestAnimationFrame","offsetX","offsetY","requestedPosition","newPosition","onInteractionEnd","onWheelRequest","pixelY","normalizeWheel","zoomSpeed","call","setTimeout","getPointOnContainer","containerTopLeft","Error","getPointOnMedia","zoomPoint","zoomTarget","getCropData","getAspect","cropData","onCropComplete","onCropAreaChange","emitCropAreaChange","onKeyDown","event","keyboardStep","step","shiftKey","newCrop","key","repeat","onKeyUp","__extends","prototype","componentDidMount","ownerDocument","defaultView","zoomWithScroll","disableAutomaticStylesInjection","createElement","setAttribute","nonce","innerHTML","head","appendChild","complete","setImageRef","setVideoRef","setCropperRef","componentWillUnmount","disconnect","parentNode","removeChild","componentDidUpdate","prevProps","objectFit","_g","_h","video","_j","load","getObjectFit","center","distance","render","image","mediaProps","cropperProps","transform","cropShape","showGrid","roundCropAreaPixels","style","containerStyle","cropAreaStyle","mediaStyle","classes","containerClassName","cropAreaClassName","mediaClassName","ref","el","data-testid","className","alt","src","concat","onLoad","autoPlay","playsInline","loop","muted","onLoadedMetadata","controls","Array","isArray","map","item","tabIndex","defaultProps","Number","clientX","clientY","touch","Component"],"mappings":"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"}