{"version":3,"file":"quill-image-drop-and-paste.cjs.min.js","sources":["../src/utils.ts","../src/ImageData.ts","../src/ImageDropAndPaste.ts"],"sourcesContent":["export default {\n  /* generate a filename\n   */\n  generateFilename(): string {\n    return btoa(String(Math.random() * 1e6) + String(+new Date())).replace(\n      '=',\n      ''\n    )\n  },\n  /* detect the giving url is a image\n   */\n  urlIsImage(url: string, abortTimeout = 3000): Promise<boolean> {\n    if (!this.validURL(url)) {\n      return Promise.reject(false)\n    }\n    if (/\\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(url)) {\n      return Promise.resolve(true)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: any = undefined\n      const img = new Image()\n      img.onerror = img.onabort = () => {\n        clearTimeout(timer)\n        reject(false)\n      }\n      img.onload = () => {\n        clearTimeout(timer)\n        resolve(true)\n      }\n      timer = setTimeout(() => {\n        img.src = '//!/an/invalid.jpg'\n        reject(false)\n      }, abortTimeout)\n      img.src = url\n    })\n  },\n  urlIsImageDataUrl(url: string): boolean {\n    return /^data:image\\/\\w+;base64,/.test(url)\n  },\n  /* check string is a valid url\n   */\n  validURL(str: string): boolean {\n    try {\n      return Boolean(new URL(str))\n    } catch (e) {\n      return false\n    }\n  },\n  /* check the giving string is a html text\n   */\n  isRichText(clipboardDataItems: DataTransferItemList): boolean {\n    let hasHtml = false\n    let hasImage = false\n    Array.prototype.forEach.call(clipboardDataItems, (item) => {\n      if (item.kind === 'string' && item.type.match(/^text\\/html$/i)) {\n        hasHtml = true\n      }\n      if (item.kind === 'file' && item.type.match(/^image\\/\\w+$/i)) {\n        hasImage = true\n      }\n    })\n    return hasHtml && !hasImage\n  },\n  /* resolve dataUrl to base64 string\n   */\n  resolveDataUrl(dataUrl: string | ArrayBuffer, type: string): string {\n    let str = ''\n    if (typeof dataUrl === 'string') {\n      str = dataUrl\n    } else if (dataUrl instanceof ArrayBuffer) {\n      str = this.arrayBufferToBase64Url(dataUrl, type)\n    }\n    return str\n  },\n  /* generate array buffer from binary string\n   */\n  binaryStringToArrayBuffer(binary: string): ArrayBuffer {\n    const len = binary.length\n    const buffer = new ArrayBuffer(len)\n    const arr = new Uint8Array(buffer)\n    let i = -1\n    while (++i < len) arr[i] = binary.charCodeAt(i)\n    return buffer\n  },\n  /* generate base64 string from array buffer\n   */\n  arrayBufferToBase64Url(arrayBuffer: ArrayBuffer, type: string): string {\n    return (\n      `data:${type};base64,` +\n      btoa(\n        new Uint8Array(arrayBuffer).reduce(\n          (acc: string, byte: number) => acc + String.fromCharCode(byte),\n          ''\n        )\n      )\n    )\n  },\n  /* copy text - make text store in the clipboard\n   */\n  copyText(content: string, target = document.body): boolean {\n    const element = document.createElement('textarea')\n    const previouslyFocusedElement = document.activeElement\n    element.value = content\n    // Prevent keyboard from showing on mobile\n    element.setAttribute('readonly', '')\n    element.style.position = 'absolute'\n    element.style.left = '-9999px'\n    element.style.fontSize = '12pt' // Prevent zooming on iOS\n    const selection = document.getSelection()\n    let originalRange: boolean | Range = false\n    if (selection && selection.rangeCount > 0) {\n      originalRange = selection.getRangeAt(0)\n    }\n    target.append(element)\n    element.select()\n    // Explicit selection workaround for iOS\n    element.selectionStart = 0\n    element.selectionEnd = content.length\n    let isSuccess = false\n    try {\n      isSuccess = document.execCommand('copy')\n      // eslint-disable-next-line no-empty\n    } catch {}\n    element.remove()\n    if (selection && originalRange) {\n      selection.removeAllRanges()\n      selection.addRange(originalRange)\n    }\n    // Get the focus back on the previously focused element, if any\n    if (previouslyFocusedElement) {\n      ;(previouslyFocusedElement as HTMLElement).focus()\n    }\n    return isSuccess\n  },\n  /* check the type of specify target\n   */\n  isType(target: any, type: string): boolean {\n    return Object.prototype.toString.call(target) === `[object ${type}]`\n  },\n  /** check the target whether is object\n   */\n  isObject(target: any): boolean {\n    return this.isType(target, 'Object')\n  },\n}\n","import utils from './utils'\nimport { IImageDataMinifyOption } from './index.d'\n\nabstract class QuillImageData {\n  public dataUrl: string | ArrayBuffer\n  public type: string\n  public name: string\n  public constructor(\n    dataUrl: string | ArrayBuffer,\n    type: string,\n    name?: string\n  ) {\n    this.dataUrl = dataUrl\n    this.type = type\n    this.name = name || ''\n  }\n  public abstract minify(option: IImageDataMinifyOption)\n  public abstract toFile(filename?: string)\n  public abstract toBlob()\n}\n\nclass ImageData extends QuillImageData {\n  dataUrl: string | ArrayBuffer\n  type: string\n  name: string\n\n  constructor(dataUrl: string | ArrayBuffer, type: string, name?: string) {\n    super(dataUrl, type, name)\n    this.dataUrl = dataUrl\n    this.type = type\n    this.name = name || `${utils.generateFilename()}.${this.getSuffix()}`\n  }\n\n  /* minify the image\n   */\n  public minify(\n    option: IImageDataMinifyOption\n  ): Promise<ImageData | { message: string }> {\n    return new Promise((resolve, reject) => {\n      const maxWidth = option.maxWidth || 800\n      const maxHeight = option.maxHeight || 800\n      const quality = option.quality || 0.8\n      if (!this.dataUrl) {\n        return reject({\n          message:\n            '[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty.',\n        })\n      }\n      const image = new Image()\n      image.onload = () => {\n        const width = image.width\n        const height = image.height\n        if (width > height) {\n          if (width > maxWidth) {\n            image.height = (height * maxWidth) / width\n            image.width = maxWidth\n          }\n        } else {\n          if (height > maxHeight) {\n            image.width = (width * maxHeight) / height\n            image.height = maxHeight\n          }\n        }\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n        const ctx = canvas.getContext('2d')\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height)\n          const canvasType = this.type || 'image/png'\n          const canvasDataUrl = canvas.toDataURL(canvasType, quality)\n          resolve(new ImageData(canvasDataUrl, canvasType, this.name))\n        } else {\n          reject({\n            message:\n              '[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure.',\n          })\n        }\n      }\n      image.src = utils.resolveDataUrl(this.dataUrl, this.type)\n    })\n  }\n\n  /* convert blob to file\n   */\n  public toFile(filename?: string): File | null {\n    filename = filename || this.name\n    if (!window.File) {\n      console.error(\n        '[error] QuillImageDropAndPaste: Your browser didnot support File API.'\n      )\n      return null\n    }\n    return new File([this.toBlob()], filename, { type: this.type })\n  }\n\n  /* convert dataURL to blob\n   */\n  public toBlob(): Blob {\n    const base64 = utils\n      .resolveDataUrl(this.dataUrl, this.type)\n      .replace(/^[^,]+,/, '')\n    const buff = utils.binaryStringToArrayBuffer(atob(base64))\n    return this.createBlob([buff], { type: this.type })\n  }\n\n  /* create blob\n   */\n  private createBlob(\n    parts: ArrayBuffer[],\n    properties: string | { type?: string } | undefined\n  ): Blob {\n    if (!properties) properties = {}\n    if (typeof properties === 'string') properties = { type: properties }\n    try {\n      return new Blob(parts, properties)\n    } catch (e: any) {\n      if (e.name !== 'TypeError') throw e\n      const Builder =\n        'BlobBuilder' in window\n          ? (window as any).BlobBuilder\n          : 'MSBlobBuilder' in window\n          ? (window as any).MSBlobBuilder\n          : 'MozBlobBuilder' in window\n          ? (window as any).MozBlobBuilder\n          : (window as any).WebKitBlobBuilder\n      const builder = new Builder()\n      for (let i = 0; i < parts.length; i++) builder.append(parts[i])\n      return builder.getBlob(properties.type) as Blob\n    }\n  }\n\n  private getSuffix(): string {\n    const matched = this.type.match(/^image\\/(\\w+)$/)\n    const suffix = matched ? matched[1] : 'png'\n    return suffix\n  }\n}\n\nexport default ImageData\n","import utils from './utils'\nimport Quill from 'quill'\nimport ImageData from './ImageData'\ninterface IImageDropAndPasteOption {\n  autoConvert?: boolean\n  enableNativeUploader?: boolean\n  handler?: (\n    dataUrl: string | ArrayBuffer,\n    type?: string,\n    imageData?: ImageData\n  ) => void\n}\n\nabstract class QuillImageDropAndPaste {\n  static ImageData\n  public quill\n  public option: IImageDropAndPasteOption\n  public constructor(quill: Quill, option: IImageDropAndPasteOption) {\n    this.quill = quill\n    this.option = option\n  }\n  protected abstract handleDrop(e: DragEvent)\n  protected abstract handlePaste(e: ClipboardEvent)\n  protected abstract readFiles(\n    files: DataTransferItemList | FileList,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent\n  )\n  protected abstract handleDataTransfer(\n    file: DataTransferItem,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent\n  )\n  protected abstract handleDroppedFile(\n    file: File,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent\n  )\n  protected abstract insert(content: string, type: string)\n  protected abstract getIndex()\n}\n\nclass ImageDropAndPaste extends QuillImageDropAndPaste {\n  static ImageData = ImageData\n  quill: Quill\n  option: IImageDropAndPasteOption\n\n  constructor(quill: Quill, option: IImageDropAndPasteOption) {\n    super(quill, option)\n    if (typeof option.autoConvert !== 'boolean') option.autoConvert = true\n    if (option.enableNativeUploader !== true) {\n      // @ts-ignore\n      utils.isObject(quill.uploader) &&\n        // @ts-ignore\n        utils.isObject(quill.uploader?.options) &&\n        // @ts-ignore\n        (quill.uploader.options.handler = () => {})\n    }\n    this.quill = quill\n    this.option = option\n    this.handleDrop = this.handleDrop.bind(this)\n    this.handlePaste = this.handlePaste.bind(this)\n    this.insert = this.insert.bind(this)\n    this.quill.root.addEventListener('drop', this.handleDrop, false)\n    this.quill.root.addEventListener('paste', this.handlePaste, false)\n  }\n\n  /* handle image drop event\n   */\n  handleDrop(e: DragEvent): void {\n    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {\n      e.preventDefault()\n      if (document.caretRangeFromPoint) {\n        const selection = document.getSelection()\n        const range = document.caretRangeFromPoint(e.clientX, e.clientY)\n        if (selection && range) {\n          selection.setBaseAndExtent(\n            range.startContainer,\n            range.startOffset,\n            range.startContainer,\n            range.startOffset\n          )\n        }\n      }\n      this.readFiles(\n        e.dataTransfer.files,\n        (dataUrl: string | ArrayBuffer, type = 'image/png', name?: string) => {\n          if (typeof this.option.handler === 'function') {\n            this.option.handler.call(\n              this,\n              dataUrl,\n              type,\n              new ImageData(dataUrl, type, name)\n            )\n          } else {\n            this.insert.call(this, utils.resolveDataUrl(dataUrl, type), type)\n          }\n        },\n        e\n      )\n    }\n  }\n\n  /* handle image paste event\n   */\n  handlePaste(e: ClipboardEvent): void {\n    if (\n      e.clipboardData &&\n      e.clipboardData.items &&\n      e.clipboardData.items.length\n    ) {\n      if (utils.isRichText(e.clipboardData.items)) return\n      this.readFiles(\n        e.clipboardData.items,\n        (dataUrl: string | ArrayBuffer, type = 'image/png') => {\n          if (typeof this.option.handler === 'function') {\n            this.option.handler.call(\n              this,\n              dataUrl,\n              type,\n              new ImageData(dataUrl, type)\n            )\n          } else {\n            this.insert(utils.resolveDataUrl(dataUrl, type), 'image')\n          }\n        },\n        e\n      )\n    }\n  }\n\n  /* read the files\n   */\n  readFiles(\n    files: DataTransferItemList | FileList,\n    callback: (\n      dataUrl: string | ArrayBuffer,\n      type: string,\n      name?: string\n    ) => void,\n    e: ClipboardEvent | DragEvent\n  ): void {\n    Array.prototype.forEach.call(files, (file: DataTransferItem | File) => {\n      if (utils.isType(file, 'DataTransferItem')) {\n        this.handleDataTransfer(file as DataTransferItem, callback, e)\n      } else if (file instanceof File) {\n        this.handleDroppedFile(file, callback, e)\n      }\n    })\n  }\n\n  /* handle the pasted data\n   */\n  handleDataTransfer(\n    file: DataTransferItem,\n    callback: (\n      dataUrl: string | ArrayBuffer,\n      type: string,\n      name?: string\n    ) => void,\n    e: ClipboardEvent | DragEvent\n  ): void {\n    const that = this\n    const { type } = file\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\n      e.preventDefault()\n      const reader = new FileReader()\n      reader.onload = (e: ProgressEvent<FileReader>) => {\n        if (e.target && e.target.result) {\n          callback(e.target.result, type)\n        }\n      }\n      const blob = file.getAsFile ? file.getAsFile() : file\n      if (blob instanceof Blob) reader.readAsDataURL(blob)\n    } else if (type.match(/^text\\/plain$/i)) {\n      file.getAsString((s) => {\n        // Don't preventDefault here, because there might be clipboard matchers need to be triggered\n        // see https://github.com/chenjuneking/quill-image-drop-and-paste/issues/37\n        if (utils.urlIsImageDataUrl(s)) {\n          // If the url is a dataUrl, just fire the callback\n          const matched = s.match(/^data:(image\\/\\w+);base64,/)\n          const t = matched ? matched[1] : 'image/png'\n          const i = this.getIndex()\n          callback(s, t)\n          this.quill.deleteText(i, s.length, 'user')\n          this.quill.setSelection(i as any)\n        } else {\n          if (this.option.autoConvert) {\n            utils\n              .urlIsImage(s)\n              .then(() => {\n                // If the url isn't a dataUrl, delete the pasted text and insert the image\n                setTimeout(() => {\n                  const i = this.getIndex()\n                  this.quill.deleteText(i - s.length, s.length, 'user')\n                  that.insert(s, 'image', i - s.length)\n                })\n              })\n              .catch(() => {\n                // Otherwise, do nothing\n              })\n          }\n        }\n      })\n    }\n  }\n\n  /* handle the dropped data\n   */\n  handleDroppedFile(\n    file: File,\n    callback: (\n      dataUrl: string | ArrayBuffer,\n      type: string,\n      name?: string\n    ) => void,\n    e: ClipboardEvent | DragEvent\n  ): void {\n    const { type, name = '' } = file\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\n      e.preventDefault()\n      const reader = new FileReader()\n      reader.onload = (e: ProgressEvent<FileReader>) => {\n        if (e.target && e.target.result) {\n          callback(e.target.result, type, name)\n        }\n      }\n      reader.readAsDataURL(file)\n    }\n  }\n\n  /* insert into the editor\n   */\n  insert(content: string, type: string, index?: number): void {\n    index = index === undefined ? this.getIndex() : index\n    let _index: any\n    if (type.startsWith('image')) {\n      _index = index + 1\n      this.quill.insertEmbed(index, 'image', content, 'user')\n    } else if (type.startsWith('text')) {\n      _index = index + content.length\n      this.quill.insertText(index, content, 'user')\n    }\n    setTimeout(() => {\n      this.quill.setSelection(_index)\n    })\n  }\n\n  getIndex(): number {\n    let index: number | undefined = (this.quill.getSelection(true) || {}).index\n    if (index === undefined || index < 0) index = this.quill.getLength()\n    return index\n  }\n}\n\n;(window as any).QuillImageDropAndPaste = ImageDropAndPaste\nif ('Quill' in window) {\n  ;(window as any).Quill.register(\n    'modules/imageDropAndPaste',\n    ImageDropAndPaste\n  )\n}\n\nexport default ImageDropAndPaste\n"],"names":["utils","generateFilename","btoa","String","Math","random","Date","replace","urlIsImage","url","abortTimeout","this","validURL","test","Promise","resolve","reject","timer","img","Image","onerror","onabort","clearTimeout","onload","setTimeout","src","urlIsImageDataUrl","str","Boolean","URL","e","isRichText","clipboardDataItems","hasHtml","hasImage","Array","prototype","forEach","call","item","kind","type","match","resolveDataUrl","dataUrl","ArrayBuffer","arrayBufferToBase64Url","binaryStringToArrayBuffer","binary","len","length","buffer","arr","Uint8Array","i","charCodeAt","arrayBuffer","reduce","acc","byte","fromCharCode","copyText","content","target","document","body","element","createElement","previouslyFocusedElement","activeElement","value","setAttribute","style","position","left","fontSize","selection","getSelection","originalRange","rangeCount","getRangeAt","append","select","selectionStart","selectionEnd","isSuccess","execCommand","_a","remove","removeAllRanges","addRange","focus","isType","Object","toString","isObject","QuillImageData","constructor","name","ImageData","super","getSuffix","minify","option","maxWidth","maxHeight","quality","message","image","width","height","canvas","ctx","getContext","drawImage","canvasType","canvasDataUrl","toDataURL","toFile","filename","window","File","toBlob","console","error","base64","buff","atob","createBlob","parts","properties","Blob","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","getBlob","matched","QuillImageDropAndPaste","quill","ImageDropAndPaste","autoConvert","enableNativeUploader","uploader","options","handler","handleDrop","bind","handlePaste","insert","root","addEventListener","dataTransfer","files","preventDefault","caretRangeFromPoint","range","clientX","clientY","setBaseAndExtent","startContainer","startOffset","readFiles","clipboardData","items","callback","file","handleDataTransfer","handleDroppedFile","that","reader","FileReader","result","blob","getAsFile","readAsDataURL","getAsString","s","t","getIndex","deleteText","setSelection","then","catch","index","_index","undefined","startsWith","insertEmbed","insertText","getLength","Quill","register"],"mappings":"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"}